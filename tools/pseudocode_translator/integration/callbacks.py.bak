"""
Callback system for client integration.

This module provides callback interfaces and managers for integrating
the pseudocode translator with external clients, enabling real-time
progress updates, status monitoring, and error handling.
"""

from __future__ import annotations

import logging
import threading
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any, Protocol

logger = logging.getLogger(__name__)


class CallbackType(Enum):
    """Types of callbacks understood by the translation system."""

    PROGRESS = "progress"
    STATUS = "status"
    COMPLETION = "completion"
    ERROR = "error"
    WARNING = "warning"
    LOG = "log"


@dataclass
class CallbackData:
    """Payload delivered to callbacks."""

    type: CallbackType
    timestamp: datetime = field(default_factory=datetime.now)
    data: dict[str, Any] = field(default_factory=dict)
    message: str | None = None

    def to_dict(self) -> dict[str, Any]:
        """Convert the payload into a serialisable dictionary."""

        return {
            "type": self.type.value,
            "timestamp": self.timestamp.isoformat(),
            "message": self.message,
            "data": self.data,
        }


class TranslationCallback(Protocol):
    """Protocol implemented by all translation callbacks."""

    def __call__(self, data: CallbackData) -> None:
        """Process a callback payload."""
        ...


class ProgressCallback(Protocol):
    """Protocol for progress callbacks."""

    def __call__(self, percentage: int, message: str) -> None:
        ...


class StatusCallback(Protocol):
    """Protocol for status callbacks."""

    def __call__(self, status: str, details: dict[str, Any] | None = None) -> None:
        ...


class BaseCallback(ABC):
    """Base class for implementing reusable callbacks."""

    def __init__(self, name: str | None = None):
        self.name = name or self.__class__.__name__
        self._enabled = True
        self._lock = threading.Lock()

    @abstractmethod
    def handle(self, data: CallbackData) -> None:
        """Handle the provided callback data."""

    def __call__(self, data: CallbackData) -> None:
        if not self._enabled:
            return
        with self._lock:
            self.handle(data)

    def enable(self) -> None:
        """Enable callback processing."""

        self._enabled = True

    def disable(self) -> None:
        """Disable callback processing."""

        self._enabled = False


class CallbackManager:
    """Coordinator that manages callback registration and dispatch."""

    def __init__(self) -> None:
        self._callbacks: dict[str, list[TranslationCallback]] = {
            callback_type.value: [] for callback_type in CallbackType
        }
        self._global_callbacks: list[TranslationCallback] = []
        self._lock = threading.RLock()

    def register(
        self,
        callback: TranslationCallback,
        callback_type: CallbackType | None = None,
    ) -> None:
        """Register a callback for a specific type or globally."""

        with self._lock:
            if callback_type is not None:
                bucket = self._callbacks[callback_type.value]
                if callback not in bucket:
                    bucket.append(callback)
            elif callback not in self._global_callbacks:
                self._global_callbacks.append(callback)

    def unregister(
        self,
        callback: TranslationCallback,
        callback_type: CallbackType | None = None,
    ) -> None:
        """Remove a previously registered callback."""

        with self._lock:
            if callback_type is not None:
                bucket = self._callbacks[callback_type.value]
                if callback in bucket:
                    bucket.remove(callback)
                return

            if callback in self._global_callbacks:
                self._global_callbacks.remove(callback)
            for bucket in self._callbacks.values():
                if callback in bucket:
                    bucket.remove(callback)

    def clear(self) -> None:
        """Remove all callbacks."""

        with self._lock:
            for bucket in self._callbacks.values():
                bucket.clear()
            self._global_callbacks.clear()

    def trigger(self, data: CallbackData) -> None:
        """Trigger callbacks for the given payload."""

        with self._lock:
            specific_callbacks = list(self._callbacks[data.type.value])
            global_callbacks = list(self._global_callbacks)

        for callback in specific_callbacks + global_callbacks:
            try:
                callback(data)
            except Exception as exc:  # pragma: no cover - defensive logging only
                logger.error("Error in %s callback: %s", data.type.value, exc)

    def trigger_progress(self, percentage: int, message: str) -> None:
        """Helper for emitting progress updates."""

        self.trigger(
            CallbackData(
                type=CallbackType.PROGRESS,
                message=message,
                data={"percentage": percentage},
            )
        )

    def trigger_status(self, status: str, **details: Any) -> None:
        """Helper for emitting status updates."""

        self.trigger(
            CallbackData(
                type=CallbackType.STATUS,
                message=status,
                data=details,
            )
        )

    def trigger_completion(self, **payload: Any) -> None:
        """Helper for signalling completion events."""

        self.trigger(
            CallbackData(
                type=CallbackType.COMPLETION,
                data=payload,
            )
        )

    def trigger_error(self, message: str, **details: Any) -> None:
        """Helper for emitting error notifications."""

        self.trigger(
            CallbackData(
                type=CallbackType.ERROR,
                message=message,
                data=details,
            )
        )

    def trigger_warning(self, message: str, **details: Any) -> None:
        """Helper for emitting warnings."""

        self.trigger(
            CallbackData(
                type=CallbackType.WARNING,
                message=message,
                data=details,
            )
        )


# Example usage:
#
#     from pseudocode_translator.integration.callbacks import (
#         CallbackManager, CallbackType, CallbackData
#     )
#
#     manager = CallbackManager()
#
#     def on_progress(data: CallbackData) -> None:
#         print(f"Progress: {data.data['percentage']}% - {data.message}")
#
#     manager.register(on_progress, CallbackType.PROGRESS)
#     manager.trigger_progress(50, "Half way there!")
#
# The same manager can be shared across desktop, web, or mobile front-ends.


__all__ = [
    "CallbackType",
    "CallbackData",
    "TranslationCallback",
    "ProgressCallback",
    "StatusCallback",
    "BaseCallback",
    "CallbackManager",
]
